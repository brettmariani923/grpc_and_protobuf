syntax = "proto3";

package grpcAndProtobuf;

option csharp_namespace = "AI.Proto";

// ===========================
//  TEXT GENERATION SERVICE
// ===========================
service TextGeneration {
  // Non-streaming (returns full output)
  rpc Generate(GenerateRequest) returns (GenerateResponse); //will return big block of text once its finished

  // Streaming (returns tokens as they generate)
  rpc GenerateStream(GenerateRequest) returns (stream GenerateStreamResponse); //like chat gpt, where each letter or word shows up as it generates
}

//The numbers below represent field tags — they are part of how Protocol Buffers (protobuf) works.
//They are not indexes, array positions, or ordering indicators.
//They are binary identifiers used during serialization. 

//In protobuf, every field needs a unique numeric tag.
//These numbers determine:
//How data is encoded into the binary protobuf format
//How the recipient decodes the message
//Backward & forward compatibility
//they are required.

//Why numbers instead of names?
//Because protobuf messages are transmitted as binary, not JSON.
//Binary format can't store field names efficiently, so protobuf uses:

//field tag number

//wire type

//value

//Each field turns into something like:
//<field 1>: "gpt-4"
//<field 2>: "Write me a poem"
//<field 3>: 200
//...

//This makes it super compact and fast.

//Why must they be unique and never changed?

//Because once clients depend on your schema, you must not change a tag number.

//If you rename a field: ✔ safe
//If you reorder fields: ✔ safe
//If you change a tag number: ❌ breaks every client

//Because the binary data would decode incorrectly.

//Why is this useful?

//It allows protobuf to be:

//blazing fast

//forward/backward compatible

//language-independent

//very compact over the wire

//That’s why gRPC is much faster than REST + JSON.

//The numbers are field IDs used in protobuf's binary encoding.
//they identify fields at runtime.
//They must be unique and never changed.

//So we are just defining these values with numbers, and the numbers are used by protobuf instead of the names

// ===========================
//  REQUEST OBJECT
// ===========================
message GenerateRequest {
  string model = 1;                           // "gpt-4", "llama-3", etc.
  string prompt = 2;                          // User prompt or message
  int32 max_tokens = 3;                       // Max output
  float temperature = 4;                      // Randomness
  float top_p = 5;                            // Nucleus sampling
  repeated string stop = 6;                   // Stop sequences
  map<string, string> metadata = 7;           // Custom headers / tags
}

// ===========================
//  FULL RESPONSE
// ===========================
message GenerateResponse {
  string content = 1;                         // Full AI output
  Usage usage = 2;                            // Token counts
  string finish_reason = 3;                   // "stop", "max_tokens", etc.
}

// ===========================
//  STREAMING RESPONSE
// ===========================
message GenerateStreamResponse {
  string token = 1;                           // One generated token
  bool is_final = 2;                          // True when done
  Usage usage = 3;                            // Final usage only sent at end
  string finish_reason = 4;                   // Reason for stopping
}

// ===========================
//  TOKEN USAGE
// ===========================
message Usage {
  int32 prompt_tokens = 1;
  int32 completion_tokens = 2;
  int32 total_tokens = 3;
}


